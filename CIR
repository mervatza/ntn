import numpy as np
import matplotlib.pyplot as plt

# === Simulation Setup ===
numDrones = 2
numUsers = 5
areaSize = 1000
droneSpeed = 20  # [m/s]
droneAltitudes = np.array([100, 200])  # [m]
timeStep = 1  # [s]
maxTime = 5  # shortened for simulation
fc = 2e9  # [Hz]
c = 3e8
lambda_c = c / fc
v = 30  # relative speed [m/s]
fs = 1000  # for fading simulation
t_fade = np.arange(0, timeStep, 1/fs)

# === TDL-A profile ===
delays_ns = np.array([0, 30, 70, 90, 110, 190])
powers_dB = np.array([0, -4, -8, -10, -15, -20])
powers_linear = 10 ** (powers_dB / 10)
powers_linear /= np.sum(powers_linear)
delays_s = delays_ns * 1e-9
N_paths = len(delays_s)
fD_max = v / lambda_c
doppler_shifts = np.linspace(-fD_max, fD_max, N_paths)

# === Users and drones positions ===
np.random.seed(0)
users = np.hstack((areaSize * (np.random.rand(numUsers, 2) - 0.5), np.zeros((numUsers, 1))))
drones = np.hstack((areaSize * (np.random.rand(numDrones, 2) - 0.5), droneAltitudes.reshape(-1, 1)))

# === Core Function to Compute CIR with Pathloss ===
def compute_cir(uav_pos, user_pos, fc, scenario="Urban Macro"):
    # Distance and elevation
    delta_xy = uav_pos[:2] - user_pos[:2]
    d_3d = np.linalg.norm(uav_pos - user_pos)
    theta = np.degrees(np.arctan2(uav_pos[2], np.linalg.norm(delta_xy)))

    # LoS probability
    a, b = 9.61, 0.16  # Urban Macro
    P_LoS = 1 / (1 + a * np.exp(-b * (theta - a)))

    # Path loss
    PL_LoS = 28 + 22 * np.log10(d_3d) + 20 * np.log10(fc / 1e9)
    PL_NLoS = 13.54 + 39.08 * np.log10(d_3d) + 20 * np.log10(fc / 1e9) - 0.6 * (uav_pos[2] - 1.5)
    PL = P_LoS * PL_LoS + (1 - P_LoS) * PL_NLoS
    G_PL = 10 ** (-PL / 10)

    # K-factor
    if P_LoS > 0.8:
        K_dB = 10 + 0.1 * (theta - 30)
    elif P_LoS > 0.3:
        K_dB = 3
    else:
        K_dB = 0
    K = 10 ** (K_dB / 10)
    mu = np.sqrt(K / (K + 1))
    sigma = np.sqrt(1 / (2 * (K + 1)))

    # CIR(taps, time)
    cir = np.zeros((N_paths, len(t_fade)), dtype=complex)
    for n in range(N_paths):
        fading = mu + sigma * (np.random.randn(len(t_fade)) + 1j * np.random.randn(len(t_fade)))
        doppler = np.exp(1j * 2 * np.pi * doppler_shifts[n] * t_fade)
        cir[n, :] = np.sqrt(G_PL * powers_linear[n]) * fading * doppler
    return cir, delays_ns, PL, K_dB

# === Run Simulation for one time step
cir_all = []
for d in range(numDrones):
    for u in range(numUsers):
        cir, delays, ploss, kdb = compute_cir(drones[d], users[u], fc)
        cir_all.append({
            'drone': d,
            'user': u,
            'cir': cir,
            'delays_ns': delays,
            'pathloss_dB': ploss,
            'K_dB': kdb
        })

# === Visualization of one CIR
example = cir_all[0]
plt.figure(figsize=(10, 6))
plt.imshow(20 * np.log10(np.abs(example['cir']) + 1e-8), aspect='auto',
           extent=[t_fade[0], t_fade[-1], delays_ns[-1], delays_ns[0]])
plt.title(f"UAV CIR | Drone {example['drone']} -> User {example['user']} | PL={example['pathloss_dB']:.1f} dB | K={example['K_dB']:.1f} dB")
plt.xlabel("Time [s]")
plt.ylabel("Delay [ns]")
plt.colorbar(label="Magnitude [dB]")
plt.tight_layout()
plt.show()

